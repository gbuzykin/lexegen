// Parsegen autogenerated analyzer file - do not edit!

static int action_idx[32] = {
    0, 12, 20, 32, 0, 42, 44, 46, 48, 50, 58, 0, 0, 60, 62, 66, 68, 70, 72, 76, 80, 84, 88, 94, 96, 100, 102, 104, 108,
    112, 114, 124
};

static int action_list[126] = {
    40, 9, 261, 11, 262, 13, 263, 15, 264, 17, -1, -1, 47, 23, 124, 25, 260, 63, -1, -1, 40, 9, 261, 11, 262, 13, 263,
    15, 264, 17, -1, 18, 42, 31, 43, 33, 63, 35, 123, 37, -1, 24, -1, 96, -1, 102, -1, 108, -1, 114, 41, 21, 47, 23,
    124, 25, -1, -1, -1, 36, -1, 12, 124, 25, -1, 6, -1, 42, -1, 48, -1, 54, 265, 41, -1, 72, 44, 55, -1, -1, 44, 45,
    -1, 60, 125, 53, -1, -1, 125, 47, 265, 49, -1, -1, -1, 84, 125, 51, -1, -1, -1, 90, -1, 66, 265, 57, -1, -1, 125,
    59, -1, -1, -1, 78, 42, 31, 43, 33, 63, 35, 123, 37, -1, 30, -1, 0
};

static int reduce_info[60] = {
    2, 0, 0, 3, 2, 1, 3, 2, 2, 1, 2, 0, 1, 10, 0, 2, 10, 3, 3, 12, 0, 2, 12, 4, 2, 12, 5, 2, 12, 6, 0, 16, 8, 5, 12, 9,
    0, 18, 7, 6, 12, 9, 5, 12, 10, 6, 12, 9, 1, 12, 0, 1, 12, 0, 1, 12, 0, 1, 12, 0
};

static int goto_list[20] = {
    -1, 0, 4, 9, 11, 14, 12, 13, -1, 1, -1, 2, 2, 30, -1, 3, -1, 21, -1, 19
};

static int parse(int tt, std::vector<int>& state_stack, unsigned& rlen, int rise_error) {
    enum { kShiftFlag = 1, kFlagCount = 1 };
    int action = rise_error;
    if (action >= 0) {
        const int* action_tbl = &action_list[action_idx[state_stack.back()]];
        while (action_tbl[0] >= 0 && action_tbl[0] != tt) { action_tbl += 2; }
        action = action_tbl[1];
    }
    if (action < 0) {  // Roll back to state, which can accept error
        rlen = 0;
        do {
            const int* action_tbl = &action_list[action_idx[state_stack.back()]];
            while (action_tbl[0] >= 0 && action_tbl[0] != predef_tt_error) { action_tbl += 2; }
            if (action_tbl[1] >= 0 && (action_tbl[1] & kShiftFlag)) {  // Can recover
                state_stack.push_back(action_tbl[1] >> kFlagCount);    // Shift error token
                break;
            }
            state_stack.pop_back();
            ++rlen;
        } while (!state_stack.empty());
        return action;
    } else if (action & kShiftFlag) {
        state_stack.push_back(action >> kFlagCount);
        return predef_act_shift;
    }
    const int* info = &reduce_info[action >> kFlagCount];
    rlen = static_cast<unsigned>(info[0]);
    state_stack.erase(state_stack.end() - rlen, state_stack.end());
    int state = state_stack.back();
    const int* goto_tbl = &goto_list[info[1]];
    while (goto_tbl[0] >= 0 && goto_tbl[0] != state) { goto_tbl += 2; }
    state_stack.push_back(goto_tbl[1]);
    return predef_act_reduce + info[2];
}
