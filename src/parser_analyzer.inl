// Parsegen autogenerated analyzer file - do not edit!

static int action_idx[32] = {
    0, 12, 20, 32, 0, 42, 44, 46, 48, 50, 58, 0, 0, 60, 62, 66, 68, 70, 72, 76, 80, 84, 88, 94, 96, 100, 102, 104, 108,
    112, 114, 124
};

static int action_list[126] = {
    40, 9, 261, 11, 262, 13, 263, 15, 264, 17, -1, -1, 47, 23, 124, 25, 260, 63, -1, -1, 40, 9, 261, 11, 262, 13, 263,
    15, 264, 17, -1, 18, 42, 31, 43, 33, 63, 35, 123, 37, -1, 24, -1, 96, -1, 102, -1, 108, -1, 114, 41, 21, 47, 23,
    124, 25, -1, -1, -1, 36, -1, 12, 124, 25, -1, 6, -1, 42, -1, 48, -1, 54, 265, 41, -1, 72, 44, 55, -1, -1, 44, 45,
    -1, 60, 125, 53, -1, -1, 125, 47, 265, 49, -1, -1, -1, 84, 125, 51, -1, -1, -1, 90, -1, 66, 265, 57, -1, -1, 125,
    59, -1, -1, -1, 78, 42, 31, 43, 33, 63, 35, 123, 37, -1, 30, -1, 0
};

static int reduce_info[60] = {
    2, 0, 0, 3, 2, 1, 3, 2, 2, 1, 2, 0, 1, 10, 0, 2, 10, 3, 3, 12, 0, 2, 12, 4, 2, 12, 5, 2, 12, 6, 0, 16, 8, 5, 12, 9,
    0, 18, 7, 6, 12, 9, 5, 12, 10, 6, 12, 9, 1, 12, 0, 1, 12, 0, 1, 12, 0, 1, 12, 0
};

static int goto_list[20] = {
    -1, 0, 4, 9, 11, 14, 12, 13, -1, 1, -1, 2, 2, 30, -1, 3, -1, 21, -1, 19
};

std::pair<bool, int> parse(CtxData& ctx, std::vector<int>& state_stack, int tt) {
    enum { kShiftFlag = 1, kFlagCount = 1 };
    int action = -1;
    if (!ctx.rise_error) {
        const int* action_tbl = &action_list[action_idx[state_stack.back()]];
        while (action_tbl[0] >= 0 && action_tbl[0] != tt) { action_tbl += 2; }
        action = action_tbl[1];
    }
    ctx.reduce_length = 0;
    ctx.rise_error = false;
    if (action < 0) {  // Roll back to the state accepting error
        ctx.can_recover = false;
        do {
            const int* action_tbl = &action_list[action_idx[state_stack.back()]];
            while (action_tbl[0] >= 0 && action_tbl[0] != predef_tt_error) { action_tbl += 2; }
            int err_action = action_tbl[1];
            if (err_action >= 0 && (err_action & kShiftFlag)) {  // Shift error token
                state_stack.push_back(err_action >> kFlagCount);
                ctx.can_recover = true;  // Can recover
                break;
            }
            ++ctx.reduce_length;
            state_stack.pop_back();
        } while (!state_stack.empty());
        return {true, action};
    } else if (action & kShiftFlag) {
        state_stack.push_back(action >> kFlagCount);
        return {false, 1};
    }
    const int* info = &reduce_info[action >> kFlagCount];
    ctx.reduce_length = info[0];
    state_stack.erase(state_stack.end() - info[0], state_stack.end());
    int state = state_stack.back();
    const int* goto_tbl = &goto_list[info[1]];
    while (goto_tbl[0] >= 0 && goto_tbl[0] != state) { goto_tbl += 2; }
    state_stack.push_back(goto_tbl[1]);
    return {true, info[2]};
}
